
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: notebook.ipynb

import cv2 #Only to be used for Canny Edge Detector
import numpy as np
from scipy import stats
import test_simple as tests
import sys
np.set_printoptions(threshold=sys.maxsize)
Checker = tests.PS02Test()

def traffic_light_detection(img_in, radii_range):
    """Finds the coordinates of a traffic light image given a radii
    range.
    Use the radii range to find the circles in the traffic light and
    identify which of them represents the yellow light.
    Analyze the states of all three lights and determine whether the
    traffic light is red, yellow, or green. This will be referred to
    as the 'state'.
    It is recommended you use Hough transform to find these circles in
    the image.
    The input image may be just the traffic light with a white
    background or a larger image of a scene containing a traffic
    light.
    Args:
        img_in (numpy.array BGR): image containing a traffic light.
        radii_range (list): range of radii values to search for.
    Returns:
        tuple: 2-element tuple containing:
        coordinates (tuple): traffic light center using the (x, y)
                             convention.
        state (str): traffic light state. A value in {'red', 'yellow',
                     'green'}
        Numpy array: Height x Width matrix of Hough accumulator array  (Height and width from the image)
    """
    threshold = 8.1
    region = 15

    medianImg = np.median(img_in)
    edgeImg = cv2.Canny(img_in, int(max(0, 0.66 * medianImg)), int(min(255, 1.33 * medianImg)))
    h, w = edgeImg.shape
    A = np.zeros((len(radii_range), h, w))
    B = np.zeros((h, w))

    angles = np.arange(360) * np.pi / 180
    edges = np.argwhere(edgeImg)
    for i, r in enumerate(radii_range):
        c = np.zeros((2*r, 2*r))
        cx, cy = r, r
        for angle in angles:
            dx = int(np.round(r*np.cos(angle)))
            dy = int(np.round(r*np.sin(angle)))
            c[cx + dx - 1, cy + dy - 1] = 1
        constant = np.argwhere(c).shape[0]
#         print(constant)
        for ex, ey in edges:
            for dx in range(-r, r):
                for dy in range(-r, r):
                    x, y = ex + dx, ey + dy
                    if x >= 0 and x < h and y >= 0 and y < w:
                        A[i][x][y] += c[dx + r][dy + r]
        A[i][A[i] < threshold * constant / r] = 0

    for r, x, y in np.argwhere(A):
        temp = A[:, x - region: x + region, y - region: y + region]
        try:
            i, j, k = np.unravel_index(np.argmax(temp), temp.shape)
        except:
            continue
        B[x - region + j][y - region + k] = radii_range[i]

    circleCoords = np.argwhere(B)
    cy = circleCoords[:, 0]
    cx = circleCoords[:, 1]
    maxv = 0

    rgb_top = img_in[cy[0]][cx[0]]
    rgb_middle = img_in[cy[1]][cx[1]]
    rgb_bottom = img_in[cy[2]][cx[2]]

    print(rgb_top)
    print(rgb_middle)
    print(rgb_bottom)

    status = ''
    if rgb_top[2] > 250 and rgb_top[1] < 10 and rgb_top[0] < 10:
        status = 'red'
    if rgb_middle[2] > 250 and rgb_middle[1] > 250 and rgb_middle[0] < 10:
        status = 'yellow'
    if rgb_bottom[2] < 10 and rgb_bottom[1] > 250 and rgb_bottom[0] < 10:
        status = 'green'

    return ((cx[1], cy[1]), status), B


from matplotlib import pyplot as plt
def valid_point(pt, ymax, xmax):
    '''
    @return True/False if pt is with bounds for an xmax by ymax image
    '''
    x, y = pt
    if x <= xmax and x >= 0 and y <= ymax and y >= 0:
        return True
    else:
        return False

def round_tup(tup):
    '''
    @return closest integer for each number in a point for referencing
    a particular pixel in an image
    '''
    x,y = [int(round(num)) for num in tup]
    return (x,y)

def make_line_and_point(img, theta, rho, x, y):
    im_y_max, im_x_max = img.shape
    m = -np.cos(theta) / np.sin(theta)
    b = rho / np.sin(theta)
    # possible intersections on image edges
    left = (0, b)
    right = (im_x_max, im_x_max * m + b)
    top = (-b / m, 0)
    bottom = ((im_y_max - b) / m, im_y_max)

    pts = [pt for pt in [left, right, top, bottom] if valid_point(pt, im_y_max, im_x_max)]
    if len(pts) == 2:
        cv2.line(img, round_tup(pts[0]), round_tup(pts[1]), (255,255,255), 3)
        cv2.circle(img, (x, y), 10, (255,255,255), 3)

def yield_sign_detection(img_in):
    """Finds the centroid coordinates of a yield sign in the provided
    image.
    Args:
        img_in (numpy.array BGR): image containing a traffic light.
    Returns:
        (x,y) tuple of coordinates of the center of the yield sign.
        Numpy array: Height x Width matrix of Hough accumulator array  (Height and width from the image)
    """
    threshold = 4
    region = 15
    radii_range = [40]

    medianImg = np.median(img_in)
    edgeImg = cv2.Canny(img_in, int(max(0, 0.66 * medianImg)), int(min(255, 1.33 * medianImg)))
    h, w = edgeImg.shape
    A = np.zeros((len(radii_range), h, w))
    B = np.zeros((h, w))

    angles = np.arange(360) * np.pi / 180
    edges = np.argwhere(edgeImg)
    for i, r in enumerate(radii_range):
        c = np.zeros((2*r, 2*r))
        cx, cy = r, r
        for angle in angles:
            dx = int(np.round(r*np.cos(angle)))
            dy = int(np.round(r*np.sin(angle)))
            c[cx + dx - 1, cy + dy - 1] = 1
        constant = np.argwhere(c).shape[0]
#         print(constant)
        for ex, ey in edges:
            for dx in range(-r, r):
                for dy in range(-r, r):
                    x, y = ex + dx, ey + dy
                    if x >= 0 and x < h and y >= 0 and y < w:
                        A[i][x][y] += c[dx + r][dy + r]
        A[i][A[i] < threshold * constant / r] = 0

    for r, x, y in np.argwhere(A):
        temp = A[:, x - region: x + region, y - region: y + region]
        try:
            i, j, k = np.unravel_index(np.argmax(temp), temp.shape)
        except:
            continue
        B[x - region + j][y - region + k] = radii_range[i]

    circleCoords = np.argwhere(B)
    print(circleCoords)
    cy = circleCoords[:, 0]
    cx = circleCoords[:, 1]

    return (np.average(cx), np.average(cy)),  B

def stop_sign_detection(img_in):
    """Finds the centroid coordinates of a stop sign in the provided
    image.
    Args:
        img_in (numpy.array BGR): image containing a traffic light.
    Returns:
        (x,y) tuple of the coordinates of the center of the stop sign.
        Numpy array: Height x Width matrix of Hough accumulator array  (Height and width from the image)
    """
    threshold = 8.1
    region = 15
    radii_range = [15]

    medianImg = np.median(img_in)
    edgeImg = cv2.Canny(img_in, int(max(0, 0.66 * medianImg)), int(min(255, 1.33 * medianImg)))
    h, w = edgeImg.shape
    A = np.zeros((len(radii_range), h, w))
    B = np.zeros((h, w))

    angles = np.arange(360) * np.pi / 180
    edges = np.argwhere(edgeImg)
    for i, r in enumerate(radii_range):
        c = np.zeros((2*r, 2*r))
        cx, cy = r, r
        for angle in angles:
            dx = int(np.round(r*np.cos(angle)))
            dy = int(np.round(r*np.sin(angle)))
            c[cx + dx - 1, cy + dy - 1] = 1
        constant = np.argwhere(c).shape[0]
#         print(constant)
        for ex, ey in edges:
            for dx in range(-r, r):
                for dy in range(-r, r):
                    x, y = ex + dx, ey + dy
                    if x >= 0 and x < h and y >= 0 and y < w:
                        A[i][x][y] += c[dx + r][dy + r]
#         A[i][A[i] < threshold * constant / r] = 0

    for r, x, y in np.argwhere(A):
        temp = A[:, x - region: x + region, y - region: y + region]
        try:
            i, j, k = np.unravel_index(np.argmax(temp), temp.shape)
        except:
            continue
        B[x - region + j][y - region + k] = radii_range[i]

    circleCoords = np.argwhere(B)
    print(circleCoords)
    cy = circleCoords[:, 0]
    cx = circleCoords[:, 1]

    return (np.average(cx), np.average(cy)),  B


def warning_sign_detection(img_in):
    """Finds the centroid coordinates of a warning sign in the
    provided image.
    Args:
        img_in (numpy.array BGR): image containing a traffic light.
    Returns:
        (x,y) tuple of the coordinates of the center of the sign.
        Numpy array: Height x Width matrix of Hough accumulator array  (Height and width from the image)
    """
    threshold = 4
    region = 15
    radii_range = [40]

    medianImg = np.median(img_in)
    edgeImg = cv2.Canny(img_in, int(max(0, 0.66 * medianImg)), int(min(255, 1.33 * medianImg)))
    h, w = edgeImg.shape
    A = np.zeros((len(radii_range), h, w))
    B = np.zeros((h, w))

    angles = np.arange(360) * np.pi / 180
    edges = np.argwhere(edgeImg)
    for i, r in enumerate(radii_range):
        c = np.zeros((2*r, 2*r))
        cx, cy = r, r
        for angle in angles:
            dx = int(np.round(r*np.cos(angle)))
            dy = int(np.round(r*np.sin(angle)))
            c[cx + dx - 1, cy + dy - 1] = 1
        constant = np.argwhere(c).shape[0]
#         print(constant)
        for ex, ey in edges:
            for dx in range(-r, r):
                for dy in range(-r, r):
                    x, y = ex + dx, ey + dy
                    if x >= 0 and x < h and y >= 0 and y < w:
                        A[i][x][y] += c[dx + r][dy + r]
        A[i][A[i] < threshold * constant / r] = 0

    for r, x, y in np.argwhere(A):
        temp = A[:, x - region: x + region, y - region: y + region]
        try:
            i, j, k = np.unravel_index(np.argmax(temp), temp.shape)
        except:
            continue
        B[x - region + j][y - region + k] = radii_range[i]

    circleCoords = np.argwhere(B)
    print(circleCoords)
    cy = circleCoords[:, 0]
    cx = circleCoords[:, 1]

    return (np.average(cx), np.average(cy)),  B

def construction_sign_detection(img_in):
    """Finds the centroid coordinates of a construction sign in the
    provided image.
    Args:
        img_in (numpy.array BGR): image containing a traffic light.
    Returns:
        (x,y) tuple of the coordinates of the center of the sign.
        Numpy array: Height x Width matrix of Hough accumulator array  (Height and width from the image)
    """
    threshold = 4
    region = 15
    radii_range = [40]

    medianImg = np.median(img_in)
    edgeImg = cv2.Canny(img_in, int(max(0, 0.66 * medianImg)), int(min(255, 1.33 * medianImg)))
    h, w = edgeImg.shape
    A = np.zeros((len(radii_range), h, w))
    B = np.zeros((h, w))

    angles = np.arange(360) * np.pi / 180
    edges = np.argwhere(edgeImg)
    for i, r in enumerate(radii_range):
        c = np.zeros((2*r, 2*r))
        cx, cy = r, r
        for angle in angles:
            dx = int(np.round(r*np.cos(angle)))
            dy = int(np.round(r*np.sin(angle)))
            c[cx + dx - 1, cy + dy - 1] = 1
        constant = np.argwhere(c).shape[0]
#         print(constant)
        for ex, ey in edges:
            for dx in range(-r, r):
                for dy in range(-r, r):
                    x, y = ex + dx, ey + dy
                    if x >= 0 and x < h and y >= 0 and y < w:
                        A[i][x][y] += c[dx + r][dy + r]
        A[i][A[i] < threshold * constant / r] = 0

    for r, x, y in np.argwhere(A):
        temp = A[:, x - region: x + region, y - region: y + region]
        try:
            i, j, k = np.unravel_index(np.argmax(temp), temp.shape)
        except:
            continue
        B[x - region + j][y - region + k] = radii_range[i]

    circleCoords = np.argwhere(B)
    print(circleCoords)
    cy = circleCoords[:, 0]
    cx = circleCoords[:, 1]

    return (np.average(cx), np.average(cy)),  B
def do_not_enter_sign_detection(img_in):
    """Find the centroid coordinates of a do not enter sign in the
    provided image.
    Args:
        img_in (numpy.array BGR): image containing a traffic light.
    Returns:
        (x,y) typle of the coordinates of the center of the sign.
        Numpy array: Height x Width matrix of Hough accumulator array  (Height and width from the image)
    """
    threshold = 8.1
    region = 15
    radii_range = [15]

    medianImg = np.median(img_in)
    edgeImg = cv2.Canny(img_in, int(max(0, 0.66 * medianImg)), int(min(255, 1.33 * medianImg)))
    h, w = edgeImg.shape
    A = np.zeros((len(radii_range), h, w))
    B = np.zeros((h, w))

    angles = np.arange(360) * np.pi / 180
    edges = np.argwhere(edgeImg)
    for i, r in enumerate(radii_range):
        c = np.zeros((2*r, 2*r))
        cx, cy = r, r
        for angle in angles:
            dx = int(np.round(r*np.cos(angle)))
            dy = int(np.round(r*np.sin(angle)))
            c[cx + dx - 1, cy + dy - 1] = 1
        constant = np.argwhere(c).shape[0]
#         print(constant)
        for ex, ey in edges:
            for dx in range(-r, r):
                for dy in range(-r, r):
                    x, y = ex + dx, ey + dy
                    if x >= 0 and x < h and y >= 0 and y < w:
                        A[i][x][y] += c[dx + r][dy + r]
#         A[i][A[i] < threshold * constant / r] = 0

    for r, x, y in np.argwhere(A):
        temp = A[:, x - region: x + region, y - region: y + region]
        try:
            i, j, k = np.unravel_index(np.argmax(temp), temp.shape)
        except:
            continue
        B[x - region + j][y - region + k] = radii_range[i]

    circleCoords = np.argwhere(B)
#     print(circleCoords)
    cy = circleCoords[:, 0]
    cx = circleCoords[:, 1]

    return (np.average(cx), np.average(cy)), B

def traffic_sign_detection(img_in):
    """Finds all traffic signs in a synthetic image.
    The image may contain at least one of the following:
    - traffic_light
    - no_entry
    - stop
    - warning
    - yield
    - construction
    Use these names for your output.
    See the instructions document for a visual definition of each
    sign.
    (Hint: Use all the functions defined above)
    Args:
        img_in (numpy.array BGR): input image containing at least one
                              traffic sign.
    Returns:
        dict: dictionary containing only the signs present in the
              image along with their respective centroid coordinates
              as tuples.
              For example: {'stop': (1, 3), 'yield': (4, 11)}
              These are just example values and may not represent a
              valid scene.
    """
    raise NotImplementedError

def detectCircles(im, radius, useGradient = False):
    """
    Args:
        im (numpy.array RGB):the input image
        radius : specifies the radius of the circle
        useGradient: a flag that allows the user to optionally exploit the gradient direction measured at the edgepoints.
    (Caution: Your x,y maybe swapped)
    Returns:
        Numpy array: N x 2 matrix in which each row lists the (x,y) position of a detectedcircles’ center
        Numpy array: Height x Width matrix of Hough accumulator array  (Height and width from the image)

    """
    raise NotImplementedError

def  detectMultipleCircles(im, radius_min,radius_max):
    """
    Args:
        im (numpy.array RGB):the input image
        radius_min : specifies the minimum radius of the circle
        radius_max : specifies the maximum radius of the circle

    (Caution: Your x,y maybe swapped)
    Returns:
        Numpy array: N x 2 matrix in which each row lists the (x,y) position of a detectedcircles’ center
        Numpy array: Height x Width matrix of Hough accumulator array (Height and width from the image)

    """
    raise NotImplementedError